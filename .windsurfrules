# vite-mf-monorepo Project Rules

## Development Environment

- **IDE**: IntelliJ IDEA (WebStorm)
- **Package Manager**: pnpm (version 10.8.1)
- **Operating System**: macOS
- **Node Version**: >= 22.11.0

## AI Assistant Workflow Rules

**CRITICAL**: These rules must be followed at all times without exception.

### Before any code modification:
1. **Ask for explicit confirmation** before modifying any code, config, or file
2. **Explain step by step** what will be modified and why
3. **Never hallucinate or invent** - if uncertain, say so and verify via code reading/tools
4. **Provide sources** (links/docs/issues) when reasoning relies on external information
5. **Ask permission before consulting documentation** - When uncertain about syntax, API, or implementation details, ALWAYS ask "Puis-je consulter la documentation [library/tool] pour vérifier ?" before using read_url_content or search_web tools. This is MANDATORY and SYSTEMATIC to avoid hallucinations.

### Commit Workflow (MANDATORY):
**Each modification step MUST follow this workflow:**
1. ✅ **Review** - Verify the code generated is correct
2. ✅ **Test** - Execute tests (unit tests, lint, type-check)
3. ✅ **Commit** - Make an atomic commit with conventional commit message

**Examples:**
- Fix bug → Review code → Run tests → Commit → Next task
- Add feature → Review code → Run tests → Commit → Next task
- Refactor → Review code → Run tests → Commit → Next task

**Forbidden:**
- ❌ Accumulating multiple changes without intermediate commits
- ❌ Skipping tests before commit
- ❌ Moving to next task without committing current changes

### Terminal commands:
- **The user executes all terminal commands** - propose commands but never execute them
- Only exception: safe read-only commands like `git status`, `ls`, `cat`

### Debug logs:
- When adding debug logs (`console.warn`/`console.error`) for investigation, **remove them** once the investigation is complete

### Language:
- All code, comments, documentation, and README files must be in **English**

## Code Generation Rules for AI

**CRITICAL**: All code generated must be compliant with the project's ESLint and Prettier configuration.

### When generating code, ALWAYS:
- Sort imports alphabetically with proper groups (builtin, external, internal, parent, sibling, index, object, type)
- Add newlines between import groups
- Use functional React components only
- Never use `console.log` (only `console.warn` or `console.error`)
- Never use explicit `any` type
- Follow BEM-like CSS naming with context prefixes
- Use strict TypeScript types
- Add proper JSDoc comments when needed
- Ensure no unused variables or imports
- Use single quotes for strings (per Prettier config)
- Use 2 spaces for indentation
- Add semicolons at end of statements

### React Component Patterns

**How to identify which pattern to use:**
- **Reusable Component**: If the request mentions "component", "UI", "reusable", "button", "input", "card", "modal", or any UI element without data fetching
- **Page Component**: If the request mentions "page", "route", "loader", "data fetching", "TanStack Query", or needs to fetch data from an API

#### 1. Reusable Components (UI Components)

**File structure:**
```
ComponentName/
├── ComponentName.tsx
├── ComponentName.css
└── ComponentName.test.tsx (if applicable)
```

**Component template:**
```typescript
import clsx from 'clsx'

import './ComponentName.css'

import type { FC, HTMLAttributes } from 'react'

export interface ComponentNameProps extends HTMLAttributes<HTMLDivElement> {
  /* Component prop description */
  propName?: string
  /* Size variant */
  size?: 'sm' | 'md' | 'lg'
  /* Visual variant */
  variant?: 'primary' | 'secondary'
}

const ComponentName: FC<ComponentNameProps> = ({
  className,
  propName,
  size = 'md',
  variant = 'primary',
  ...rest
}) => {
  return (
    <div
      className={clsx('ComponentName', size, variant, className)}
      {...rest}
    >
      {/* Component content */}
    </div>
  )
}

export default ComponentName
```

**Reusable component rules:**
- Use `clsx` for conditional class names
- Extend appropriate HTML attributes (HTMLAttributes, ButtonHTMLAttributes, etc.)
- Destructure props with defaults
- Spread remaining props with `{...rest}`
- Export interface as named export
- Export component as default
- Add JSDoc comments for all props
- Use PascalCase for root className
- Colocate CSS file

#### 2. Page Components (Route Components with Data Loading)

**File structure:**
```
PageName/
├── PageName.tsx
├── PageName.css
└── PageName.test.tsx (if applicable)
```

**Component template:**
```typescript
import { QueryClient } from '@tanstack/react-query'
import { useLoaderData, useQuery } from 'react-router-dom'

import './PageName.css'

import type { FC } from 'react'

// Type definitions
export type RouteComponent = FC & {
  loader: (queryClient: QueryClient) => () => Promise<DataType>
}

interface PageNameProps {
  // Props if needed
}

// Query definition
const query = () => ({
  queryKey: ['queryName'],
  queryFn: async () => {
    // Fetch logic
  },
})

// Loader for React Router
const loader = (queryClient: QueryClient) => async () => {
  return queryClient.ensureQueryData(query())
}

// Component
const PageName: RouteComponent = (props: PageNameProps) => {
  const initialData = useLoaderData<DataType>()

  const { data, error, isLoading } = useQuery<DataType>({
    ...query(),
    initialData,
  })

  if (isLoading) {
    return <div className="loading">Loading...</div>
  }

  if (error) {
    return <div className="error">{error.message}</div>
  }

  return (
    <div className="page-name">
      {/* Page content */}
    </div>
  )
}

export default PageName

// Attach loader to component
PageName.loader = loader
```

**Page component rules:**
- Use RouteComponent pattern for components with loaders
- Handle loading and error states explicitly
- Use kebab-case for root className
- Colocate CSS file
- Export RouteComponent type as named export
- Attach loader to component after export

**CSS naming convention (both types):**
- Root class: PascalCase for reusable components (`.Button`), kebab-case for pages (`.page-name`)
- Child elements: `.ComponentName-element` or `.page-name-element`
- Modifiers: Use clsx with variant props instead of BEM modifiers
- Context prefix for domain-specific components (e.g., `.movie-grid-card`)

**General component rules:**
- Always use functional components with arrow functions
- Export component as default
- Export types and interfaces as named exports
- Use data-testid attributes for testable elements
- Never use inline styles unless absolutely necessary

## Tech Stack

### Architecture
- **Monorepo**: Lerna 8.2.2 + pnpm workspaces (pnpm 10.8.1)
- **Micro-frontends**: Module Federation with @module-federation/vite 1.11.0
- **Build**: Vite 6.2
- **Node**: >= 22.11.0

### Frontend
- **Framework**: React 19.1.0
- **Routing**: React Router 7.5.2
- **Data fetching**: TanStack Query 5.74.4
- **Styling**: Tailwind CSS 4.1.0 with @tailwindcss/vite plugin
- **TypeScript**: 5.7.2

### API Client
- **Generator**: heyAPI 0.71.0 (OpenAPI to TypeScript)
- **HTTP Client**: @hey-api/client-fetch 0.10.0
- **Integration**: TanStack Query hooks auto-generated

### Quality
- **Linting**: ESLint 9 (flat config) + Prettier 3.5.3
- **Tests**: Vitest 3.1.2 + React Testing Library 16.3.0 + jsdom 26.1.0
- **Git hooks**: Husky 9.1.7 + commitlint + lint-staged
- **Coverage**: @vitest/coverage-v8 3.1.2

### Module Federation
- **Runtime**: @module-federation/runtime 0.24.1
- **DTS Plugin**: @module-federation/dts-plugin 0.24.1
- **CSS injection**: vite-plugin-css-injected-by-js 3.5.2
- **Top-level await**: vite-plugin-top-level-await 1.5.0

### Production
- **Server**: Express 5.1.0 with CORS
- **External API**: TMDB API (key in .env.local)

## Project Structure

### Apps (Micro-frontends)
- `apps/host`: Host application (port 3000) that consumes remotes
- `apps/list`: Remote for movie list (port 3001, route `/`)
- `apps/detail`: Remote for movie detail (port 3002, route `/detail/:id`)

### Packages (Shared libraries)
- `packages/shared`: Shared utilities (healthCheck, retry), Vite plugins (notifyHostOnHmr, tailwindRemoteCss), Tailwind theme
- `packages/ui`: Design system components (Button, Card) with Tailwind v4 and `ui:` prefix
- `packages/http-client`: TMDB API client generated with heyAPI, exported as @vite-mf-monorepo/tmdb-client

### Ports (defined in .env)
- HOST_PORT=3000
- REMOTE_LIST_PORT=3001
- REMOTE_DETAIL_PORT=3002

## Code Conventions

### TypeScript
- Strict mode enabled
- No explicit `any` (ESLint error)
- No unused variables (ESLint error)
- strictTypeChecked + stylisticTypeChecked configuration

### React
- Functional components only
- Hooks are mandatory (react-hooks/rules-of-hooks: error)
- No `console.log` (only `console.warn` and `console.error`)
- React 19 without explicit React import (automatic JSX transform)

### Imports
- Alphabetical sorting with groups: builtin, external, internal, parent, sibling, index, object, type
- Newlines between groups
- Sort-imports enabled with ignoreDeclarationSort

### CSS / Tailwind
- Tailwind CSS v4 with CSS-first configuration (no tailwind.config.js)
- Shared theme in `packages/shared/src/tailwind/theme.css` with OKLCH colors
- Host: Full Tailwind with preflight
- Remotes: Use `tailwindRemoteCss` plugin to generate CSS without preflight (avoids duplication)
- Remotes import `remote.css` (generated) instead of `index.css` for exposed components
- packages/ui uses `ui:` prefix for style isolation
- Dynamic injection via vite-plugin-css-injected-by-js in remotes

### Commits
- Conventional commits format mandatory
- Allowed types: build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test
- Type in lowercase
- Subject without trailing period
- Max 100 characters for header

## Git Workflow

### Pre-commit Hook
Automatically runs before each commit:
1. `pnpm run type-check` - TypeScript validation
2. `pnpm run lint` - ESLint check
3. `pnpm run test` - Vitest tests

All checks must pass before the commit is allowed.

### Commit Message Hook
- Uses commitlint to validate commit message format
- Enforces conventional commits standard
- Validates type, scope, and subject format

### Commit Message Format
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Examples:**
- `feat(list): add pagination to movie grid`
- `fix(detail): resolve image loading issue`
- `chore(deps): update vite to 6.2.0`
- `docs(readme): update installation instructions`

**Rules:**
- Type must be one of: build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test
- Type must be lowercase
- Scope is optional but recommended (list, detail, host, shared)
- Subject must not end with a period
- Subject must be lowercase (no PascalCase, UPPER_CASE, or sentence-case)
- Header (type + scope + subject) must not exceed 100 characters
- Body and footer are optional

## Module Federation Architecture

### Bootstrap Pattern
- Entry point: `main.tsx` → `await import('./bootstrap')`
- Allows Module Federation initialization before application code

### Standalone Remotes
- Each remote can function autonomously
- Dual configuration: standalone routes + MF exposition
- Bootstrap creates its own router and QueryClient
- Different App wrapper in standalone vs consumed by host

### Type Hinting Generation (DTS)
- Built-in DTS in @module-federation/vite 1.11.0 with @module-federation/dts-plugin 0.24.1
- Remotes: `dts.generateTypes` generates types in `dist/.dev-server/@mf-types.zip`
- Host: `dts.consumeTypes` downloads and extracts types to `@mf-types/`
- Types resolved via tsconfig paths: `"*": ["./@mf-types/*"]`
- RouteComponent pattern to expose typed loaders
- `apps/host/@mf-types/` is gitignored (auto-generated)

### Health Checks
- `checkRemoteHealth` utility in packages/shared
- Retry with backoff (5 attempts, 1s delay)
- 5s timeout per attempt
- `/health` endpoint in each Express server

### Shared Dependencies
- react, react-dom, react-router-dom, @tanstack/react-query as singletons
- Strict versions defined in MF config

## Scripts

### Development
- `pnpm dev`: Launch all packages in parallel
- `pnpm dev:ordered`: Launch in order list → detail → host
- `pnpm [package]:dev`: Launch a specific package

### Project Reset
- `pnpm reset`: Clean install simulating a fresh clone
  - Removes: node_modules, dist, .__mf__temp, @mf-types
  - Reinstalls with `pnpm install --frozen-lockfile`
  - Use this to test onboarding experience for new developers

### Production
- `pnpm prod`: Build and launch in production mode with Express servers
- Each remote exposes an Express server with CORS and /health endpoint

### Quality
- `pnpm lint`: ESLint on entire project
- `pnpm lint:fix`: ESLint with auto-fix
- `pnpm type-check`: TypeScript check without emission
- `pnpm test`: Vitest tests
- `pnpm coverage`: Tests with coverage

## Tests

### Configuration
- Workspace mode on `packages/*`
- Globals enabled (no need to import describe, it, expect)
- Setup file: vitest.setup.ts with @testing-library/jest-dom
- Coverage on `packages/*/src/**/*`

### Structure
- Tests colocated with components
- Using React Testing Library
- Mocks in `src/mocks/`

## Forbidden

### Code
- ❌ No `console.log` (use console.warn or console.error)
- ❌ No explicit `any` in TypeScript
- ❌ No unused variables/parameters
- ❌ No unsorted imports
- ❌ No CSS Modules
- ❌ No CSS-in-JS
- ❌ No custom CSS when Tailwind utilities exist

### Commits
- ❌ No commits without conventional type
- ❌ No subject in PascalCase, UPPER_CASE, or sentence-case
- ❌ No trailing period in subject
- ❌ No header > 100 characters

### Architecture
- ❌ Never modify shared dependencies without synchronizing host and remotes
- ❌ Never delete index.css files (required for standalone mode)
- ❌ Never disable cssInjectedByJsPlugin in remotes
- ❌ Never manually edit generated files in packages/http-client/src/client/ (regenerate with `pnpm generate`)

## Best Practices

### Module Federation
- Always test in standalone AND integrated in host
- Verify types are generated in @mf-types/ in dev
- Ensure health checks work before starting host
- Expose loaders with RouteComponent pattern

### Tailwind CSS
- Use Tailwind utility classes, avoid custom CSS when possible
- Shared theme tokens defined in packages/shared/src/tailwind/theme.css
- Remotes: import `../remote.css` in exposed components (not index.css)
- packages/ui: use `ui:` prefix for all classes
- Use relativeCSSInjection: true in cssInjectedByJsPlugin

### Tests
- Add data-testid on tested elements
- Use React Testing Library queries (getByRole, getByTestId, etc.)
- Mock API calls in tests

### Performance
- Use lazy loading for remotes in host
- Configure staleTime and refetch in QueryClient
- Singleton for shared dependencies

## Known Issues

### Dev Mode
- Production and standalone modes work correctly
- DTS types are generated automatically on dev server start

## Future Enhancements

- E2E tests with Playwright or Vitest browser mode
- People package for talent details
- More Tier 1 primitives in packages/ui (Image, Rating, Badge, Carousel, Input, IconButton, Skeleton)
- Storybook for component documentation
- Style Dictionary for design token management
- Dark mode support
- More tests for error cases
- Test utils in shared package
